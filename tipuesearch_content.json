{"pages":[{"url":"http://www.opdev.cn/404.html","text":"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n 404  – Opdev.cn\n\n\n\n\n\n\n\n\n\n\n\n\n    .highlight pre {\n        display: block;\n        overflow-x: auto;\n        overflow: auto;\n        counter-reset: linecounter;\n        padding-left: 1.5em;\n        /* border-left: 3px solid !important; */\n        /* border-left-color: #FF8000 !important; */\n        background: rgba(245, 245, 245, 0.25);\n        border: 1px solid #E8E8E8;\n        font-family: Menlo, 'Bitstream Vera Sans Mono', 'DejaVu Sans Mono', Monaco, Consolas, monospace;\n        margin-bottom: 10px;\n        padding-bottom: 10px;\n        padding-top: 10px;\n    }\n    .highlight pre span.code-line {\n        counter-increment: linecounter;\n        padding-left: 1em;\n        text-indent: -1.5em;\n        display: inline-block;\n        margin-left: 6px;\n        border-left: 2px solid #BBE9BB;\n    }\n    .highlight pre span.code-line:before {\n        content: counter(linecounter);\n        padding-right: 1em;\n        display: inline-block;\n        color: grey;\n        text-align: right;\n        -webkit-user-select: none;\n        -khtml-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        user-select: none;\n    }\n    blockquote {\n        background:#f9f9f9;\n        border-left:5px solid #ccc;\n        margin:1.5em 10px;\n        padding:.5em 10px;\n    }\n    blockquote:before {\n        color:#ccc;\n        content:open-quote;\n        font-size:4em;\n        line-height:.1em;\n        margin-right:.25em;\n        vertical-align:-.4em;\n    }\n    blockquote p {\n        display:inline;\n    }\n    \n\n\n    var _hmt = _hmt || [];\n    (function() {\n      var hm = document.createElement(\"script\");\n      hm.src = \"https://hm.baidu.com/hm.js?a14887a9f31eeff5459d8cbbf3da3c4f\";\n      var s = document.getElementsByTagName(\"script\")[0]; \n      s.parentNode.insertBefore(hm, s);\n    })();\n    \n\n\n    (function(){\n        var bp = document.createElement('script');\n        var curProtocol = window.location.protocol.split(':')[0];\n        if (curProtocol === 'https') {\n            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        \n        }\n        else {\n            bp.src = 'http://push.zhanzhang.baidu.com/push.js';\n        }\n        var s = document.getElementsByTagName(\"script\")[0];\n        s.parentNode.insertBefore(bp, s);\n    })();\n    \n\n\n\n\n\n\n\n首页\n博客\n监控\n项目\n聊天\n管理\n\n\n\n分享\n取消\n\n\n\nOPDEV.CN\n\n\n\n\n\n\n\n\n\n\n\n\n404\nPage Not Found\n\n                    Oh no! The page you're searching for is not here! How about going back home and trying again! \n                \nHome\n\n\n\n\n\n\n\n\n\n","tags":"","title":" 404  – Opdev.cn"},{"url":"pelican/pelican-simblog.html","text":"缘由 由于主机续费等问题，决定把博客迁移到Pelican。 主题是自己开发的，独一无二。 重要更新： 使用Pelican生成静态页面 重写了主题 托管于git 评论换为畅言 待完善功能: toc目录结构 更新 2017.03.24 初次上线部署","tags":"Pelican","title":"Pelican静态博客simblog v3.0"},{"url":"jenkins/jenkins-git-ssh.html","text":"安装 \"Git Plugin\"插件 点击系统管理->管理插件 在\"可选插件\"Tab里找到 Git Plugin ，安装该插件， 装完后重启， 在\"已安装\"Tab可找到该插件 Git路径设置 系统管理->系统设置-Git,配置git的路径和版本（一般不需要配置，会自动识别到） 认证设置 首页->Credentials->Global credentials->Add Credentials-> Scope:Global Username:jenkins (根据你的运行用户决定) Private Key:From the Jenkins master ~/.ssh (注意，这里用到的是私钥) 生成ssh keys ssh-keygen -t rsa -C \"zhengfuqiang@test.com\" cat ~/.ssh/id_rsa.pub (添加到你的git里) 新建任务 源码管理->Git Repository URL:git的ssh地址 Credentials:jenkins (刚才创建的用户)","tags":"Jenkins","title":"jenkins配置Git及ssh认证"},{"url":"rundeck/rundeck-ldap.html","text":"1.创建Active Directory组 在Active Directory中创建一个新组，命名为\"op。\"然后添加用户，AD组。 2. 创建jaas-activedirectory.conf文件 touch /etc/rundeck/jaas-activedirectory.conf chown rundeck:rundeck /etc/rundeck/jaas-activedirectory.conf vim /etc/rundeck/jaas-activedirectory.conf 线上配置文件 multiauth { com.dtolabs.rundeck.jetty.jaas.JettyCachingLdapLoginModule sufficient debug=\"true\" contextFactory=\"com.sun.jndi.ldap.LdapCtxFactory\" providerUrl=\"ldap://IP:389\" bindDn=\"cn=administrator,cn=users,dc=baidu,dc=com\" bindPassword=\"密码\" authenticationMethod=\"simple\" forceBindingLogin=\"true\" userBaseDn=\"ou=baidu,dc=baidu,dc=com\" userRdnAttribute=\"sAMAccountName\" userIdAttribute=\"sAMAccountName\" userPasswordAttribute=\"unicodePwd\" userObjectClass=\"user\" roleBaseDn=\"ou=linux,dc=baidu,dc=com\" roleNameAttribute=\"cn\" roleMemberAttribute=\"member\" roleObjectClass=\"group\" cacheDurationMillis=\"300000\" nestedGroups=true reportStatistics=\"true\"; org.eclipse.jetty.plus.jaas.spi.PropertyFileLoginModule required debug=\"true\" file=\"/etc/rundeck/realm.properties\"; }; 3.修改/etc/rundeck/profile cp /etc/rundeck/profile /etc/rundeck/profile.bak vim /etc/rundeck/profile export RDECK_JVM=\"-Djava.security.auth.login.config=/etc/rundeck/jaas-activedirectory.conf \\ -Dloginmodule.name=multiauth 4.创建ACL op.aclpolicy /var/lib/rundeck/exp/webapp/WEB-INF/web.xml + <security-role> + <role-name> op </role-name> + </security-role> touch /etc/rundeck/op.aclpolicy chown rundeck.rundeck /etc/rundeck/op.aclpolicy description : OP , read access context : project : '.*' for : resource : - equals : kind : job allow : [ read , refresh ] - equals : kind : node allow : [ read , refresh ] job : - allow : [ read , run , kill ] node : - allow : [ read , run ] by : group : 'op' --- description : OP , Read Access context : application : 'rundeck' for : resource : - equals : kind : system allow : [ read ] - equals : kind : project allow : [ read ] project : - match : name : '.*' allow : [ read ] by : group : [ 'op' ]","tags":"Rundeck","title":"rundeck整合LDAP登录"},{"url":"django/django-websocket-redis.html","text":"1.安装redis $ wget http://download.redis.io/releases/redis-3.0.7.tar.gz $ tar xzf redis-3.0.7.tar.gz $ cd redis-3.0.7 $ make $ src/redis-server 2.安装websocket # pip install django-websocket-redis 3.配置setting INSTALLED_APPS = ( ... 'ws4redis', ... ) # TEMPLATES 配置 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.core.context_processors.static', 'ws4redis.context_processors.default', 'django.contrib.messages.context_processors.messages', ], }, # WebSocket Url WEBSOCKET_URL = '/ws/' # WebSocket Redis WS4REDIS_CONNECTION = { 'host': '127.0.0.1', 'port': 6379, 'db': 10, } WS4REDIS_EXPIRE = 3600 WS4REDIS_PREFIX = 'ws' WSGI_APPLICATION = 'ws4redis.django_runserver.application' WS4REDIS_HEARTBEAT = '--heartbeat--' 4.启动websocket(这样启动websocket和django监听同一个端口) ./manage.py runserver 5.Nginx+uwsgi运行 # nginx 配置文件增加 location / ws / { proxy_http_version 1.1 ; proxy_set_header Upgrade $ http_upgrade ; proxy_set_header Connection \"upgrade\" ; proxy_pass http : // 127.0 . 0.1 : 8888 ; } # websocket配置文件 # cat wsgi_websocket.py import os import gevent.socket import redis.connection redis . connection . socket = gevent . socket os . environ . update ( DJANGO_SETTINGS_MODULE = 'simblog.product_settings' ) from ws4redis.uwsgi_runserver import uWSGIWebsocketServer application = uWSGIWebsocketServer () # uwsgi配置文件 # cat uwsgi.ini [ uwsgi ] virtualenv =/ 你的虚拟环境 /. venv / chdir =/ 你的项目路径 / module = wsgi_websocket master = True http - socket = 127.0 . 0.1 : 8888 http - websockets = true gevent = 1000 workers = 2 umask = 002 buffer - size = 32768 6.无法发送中文，自动断开链接 我在github提的issue： https://github.com/jrief/django-websocket-redis/issues/180 作者建议我升级python3.0+，我的做法是通过js转换中文为unicode字符发送，虽然不完美，但解决了我目前的问题。","tags":"Django","title":"django-websocket-redis安装配置并支持中文"},{"url":"django/django-simblog2.html","text":"重要更新： 更换了全新的模版； 保留了原主题（挺喜欢之前的主题，所以保留了原主题）； 使用Class View编写； 对代码格式及性能做了优化； 代码高亮更新问最新版的 prettify ； 待完善功能: 主机性能图形展示； 项目展示； 管理后台； 登录页； 403，404，502，500页面自定义； RSS； 首页 更新 2016.06.22 更换为markdown编辑器","tags":"Django","title":"django博客simblog v2.0"},{"url":"python/python-pep8.html","text":"转载，原作者找不到了，官网规范： https://www.python.org/dev/peps/pep-0008/ 代码布局 缩进 对于每一次缩进使用4个空格。使用括号、中括号、大括号进行垂直对齐，或者缩进对齐。 制表符还是空格? 永远不要将制表符与空格混合使用。Python最常用的缩进方式是只是用空格。 当调用Python命令行的 -t 选项时，它会检测并警告代码非法混合使用制表符和空格。当使用 -tt 选项时，警告变成了错误。 最大行长度 限制所有行最长为79个字符。 使用反斜杠来分行是一个很好的选择。 我们应当选择在二元操作符之后进行分行，而不是之前。 空行 使用两行空行来分隔顶层函数和类定义。 使用单行空行来分隔类方法定义。 在函数中使用空行来表示不同的逻辑块。 编码 Python核心发行代码里面优先使用ASCII码或Latin-1编码。3.0后UTF-8编码优先于Latin-1。 导入 每一个导入通常应当使用单独的行。 导入应当位于文件顶部，在模块注释和文档字符串之后，在全局变量和常量之前。 导入应当按以下顺序分组，且每组导入之间使用空行隔开： 1、标准库导入 2、第三方库导入 3、本地应用程序/定制库导入 使用绝对包路径导入。 表达式和语句中的空格 注释 误导的注释不如没有注释 注释应当为完整的句子，且句号结尾的句子后面应当有2个空格。如果注释很短，那么结尾的句号可以忽略。 块注释 块注释应当和代码缩进保持一致。每行注释开头应以#开头，然后紧跟一个空格。 行注释 行注释至少和语句间隔2个空格。同样的注释应当以#开头，然后紧跟一个空格。 文档字符串 对于所有的公有模块、类、函数和方法都需要编写文档字符串。 \"\"\" 作为多行的文档字符串的结束，应该单独一行，并且之前有一个空行。 对于只有一行的文档字符串来说，结尾的 \"\"\" 在同一行。 更详细的文档字符串规范见 PEP 257。 命名规范 目前Python库的命名规范尚未达成一致，但有一些推荐的标准。 在Python里面，有一些具有特定意义的下划线前缀或者后继的特殊格式。如： 1、_single_leading_underscore：（单下划线开始）弱\"内部使用\"指示器。例如：from M import * 不会导入以下划线开始的对象。 2、single_trailing_underscore_：（单下划线结束）规定使用其来避免与Python关键字冲突，例如： Tkinter.Toplevel(master, class_='ClassName') 在参数class后面加单下划线，避免与关键字class冲突 3、__double_leading_underscore：（双下划线开始）命名一个类的属性时，调用\"name mangling\"（类FooBar中，__boo 变为了 _FooBar__boo; 见下文） 4、 double_leading_and_trailing_underscore ：（双下划线开始和结束）存活在用户控制命名空间的\"magic\"对象或属性。 例如__init__, import 或 file 。永远不要起这样的名字。 避免使用的命名 不要使用小写的L、大写的O、以及大写的I作为单字符变量名。 包与模块名称 模块应当使用简短、全小写的名字，也可使用下划线连接来提高可读性。 包也应当使用简短、全小写的名字，但不要使用下划线。 这是由于模块名与文件名关联，而在某些文件系统中大小写不敏感，且会截断过长的名字。 当使用C/C++来编写一个扩展模块时，应当使用下划线作为模块名的前缀。 类名 类名应当使用驼峰式（CapWords）。内部使用的类名应当加下划线前缀。 异常名 异常也是一个类，所以需要遵循类名规则。但如果你的异常确实是个错误的话，请使用Error前缀。 全局变量名 遵循函数规则。 函数名 函数名全小写，可以使用下划线分隔来提高可读性。 函数与方法参数 使用self作为实例方法的第一个参数。 使用cls作为类方法的第一个参数。 当函数的参数名与保留字冲突时，使用下划线后缀（第二次提醒）。 方法名与实例变量 遵循函数规则。 在私有方法和实例变量前用单下划线前缀。 使用双下划线前缀来调用\"name mangling\"来避免与子类命名冲突。 如果类Foo有个属性叫__a，那么它不能使用Foo.__a读取，但仍然可以Foo._Foo__a来读取。 常量 常量通常在模块级别定义，使用全大写和下划线分隔的形式。 继承设计 在设计类的方法或实例变量时，应当觉得其实公有的还是非公有的。当不能确定时，设计为私有的。 在Python中没有真正的私有属性。 公有属性不应当使用下划线开始。 当公有属性与保留字冲突时，在名称后面加下划线后缀（第三次提醒）。 对于简单的公有属性，最好直接访问其属性名，而非get/set方法。 编程建议 代码应当适用于Python的多个实现。比如不要依赖CPython的高效字符串语句 a+=b，而应当使用join，从而保证在不同实现上的线性开销。 当与类似于None的单例（singleton)进行比较式，要使用is 或者 is not， 而不是使用等于操作。 当使用复杂比较实现排序操作时，最好实现全部的六个比较操作。 使用基于对象的异常。 模块或者包应当定义自己的异常基类，这个类应当继承自内置的Exception类。 当抛出一个异常的时候，使用raise ValueError('message')代替旧的raise ValueError, 'message'格式。这是由于当异常的参数很长或者是格式化字符串的时候，由于括号的关系，我们不需要使用多行连接符。 旧的格式在Python 3 中被移除。 当捕获一个异常的时候，要用详细的异常声明来代替简单的except: 语句。 一个空的except:语句将会捕获 SystemExit 和 KeyboardInterrrupt 异常。这会使得很难用Control-C来中断一个程序，并且还会隐藏其他的问题。 另外，对于所有的try/except语句，限制try语句来减少必要代码的数量。 再者，可以避免掩盖问题。 Yes: try : value = collection [ key ] except KeyError : return key_not_found ( key ) else : return handle_value ( value ) No: try: # Too broad! return handle_value(collection[key]) except KeyError: # Will also catch KeyError raised by handle_value() return key_not_found(key) 使用''.startswith() 和 ''.endswith()而非字符切片去检测前缀或后缀。 对象类型比较总要用 isinstance() 而非直接比较。 对于序列，(strings, lists, tuples)，利用空序列为false这一点来进行判断，而非使用长度来判断。 别用‘=='进行布尔值和 True 或者 False 的比较。","tags":"Python","title":"Python编程规范(PEP8)"},{"url":"sensu/sensu-nginx-access.html","text":"sensu日志分析插件。 nginx日志格式： # -*- coding: utf-8 -*- import os import time import json import socket import hashlib from collections import defaultdict from sensu_plugin import SensuPluginMetricGraphite class NginxAccessMetrics ( SensuPluginMetricGraphite ): \"\"\" This is a script for check nginx access \"\"\" def __init__ ( self ): self . last_metrics_dir = '/tmp/.nginx_access_metrics' if not os . path . isdir ( self . last_metrics_dir ): os . mkdir ( self . last_metrics_dir ) super ( NginxAccessMetrics , self ) . __init__ () def setup ( self ): self . parser . add_argument ( '-l' , '--log' , required = True , help = 'nginx access log' ) self . parser . add_argument ( '-s' , '--schema' , default = '{0}.nginx.access' . format ( socket . gethostname ()), help = 'metrics schema' ) def _get_offset_db ( self ): _db_file = os . path . join ( self . last_metrics_dir , '.' + hashlib . md5 ( self . options . log ) . hexdigest ()) self . offset_db = _db_file def _get_offset ( self ): _ret = { 'path' : self . options . log , 'inode' : 0 , 'offset' : 0 } if os . path . isfile ( self . offset_db ): _offset_info = open ( self . offset_db , 'r' ) . read () . strip () . split () if len ( _offset_info ) == 3 : _ret [ 'inode' ] = int ( _offset_info [ 1 ]) _ret [ 'offset' ] = int ( _offset_info [ 2 ]) return _ret def _write_offset ( self , inode , offset ): with open ( self . offset_db , 'w' ) as fd : fd . write ( '{0} {1} {2}' . format ( self . options . log , inode , offset )) def _get_timestamp ( self , time_str ): ctime = time_str . split ( '+' )[ 0 ] return time . mktime ( time . strptime ( ctime , '%Y-%m- %d T%H:%M:%S' )) def _get_log_fds ( self , inode , offset ): _ret = [] if inode == 0 : inode = os . stat ( self . options . log ) . st_ino fd = open ( self . options . log , 'r' ) _ret . append (( fd , inode )) else : if os . stat ( self . options . log ) . st_ino == inode : fd = open ( self . options . log , 'r' ) fd . seek ( offset ) _ret . append (( fd , inode )) else : # Log rotate? log_dir = os . path . dirname ( os . path . abspath ( self . options . log )) for _each in os . listdir ( log_dir ): _each = os . path . join ( log_dir , _each ) if os . stat ( _each ) . st_ino == inode : fd = open ( _each , 'r' ) fd . seek ( offset ) _ret . append (( fd , inode )) break # Add new log fd inode = os . stat ( self . options . log ) . st_ino fd = open ( self . options . log , 'r' ) _ret . append (( fd , inode )) return _ret def run ( self ): bandwidth = 0 start_time = None end_time = None domain_map = defaultdict ( dict ) self . _get_offset_db () current_offset = self . _get_offset () fds = self . _get_log_fds ( current_offset [ 'inode' ], current_offset [ 'offset' ]) for _each_fd , _each_ino in fds : for eachLine in _each_fd : try : json_Line = json . loads ( eachLine . decode ( 'unicode-escape' ), strict = False ) if start_time == None : start_time = json_Line [ '@timestamp' ] end_time = json_Line [ '@timestamp' ] if start_time > json_Line [ '@timestamp' ]: start_time = json_Line [ '@timestamp' ] elif end_time < json_Line [ '@timestamp' ]: end_time = json_Line [ '@timestamp' ] domain = json_Line [ '@fields' ][ 'host' ] status_code = int ( json_Line [ '@fields' ][ 'status' ]) bits_sent = int ( json_Line [ '@fields' ][ 'bytes_sent' ]) * 8 except Exception : continue if domain not in domain_map : domain_map [ domain ] . update ( dict ( status = defaultdict ( int ), bandwidth = 0 )) domain_map [ domain ][ 'status' ][ 'total' ] += 1 domain_map [ domain ][ 'status' ][ status_code ] += 1 domain_map [ domain ][ 'bandwidth' ] += bits_sent if start_time and end_time : start_time = self . _get_timestamp ( start_time ) end_time = self . _get_timestamp ( end_time ) end_time += 1 interval = end_time - start_time # # Write offset self . _write_offset ( _each_ino , _each_fd . tell ()) if domain_map : for domain , info in domain_map . iteritems (): for status_code , status_value in info [ 'status' ] . iteritems (): self . output ( \"{0},domain={1},type=status_code,staut_code={2}\" . format ( self . options . schema , domain , status_code ), status_value / interval ) self . output ( \"{0},domain={1},type={2}\" . format ( self . options . schema , domain , 'bandwidth' ), info [ 'bandwidth' ] / interval ) self . ok () if __name__ == \"__main__\" : NginxAccessMetrics ()","tags":"Sensu","title":"sensu插件nginx-access"},{"url":"sensu/sensu-nginx-status.html","text":"第一次写sensu的插件，暂作格式规范记录。 地址： https://github.com/sensu/sensu-plugin-python # -*- coding: utf-8 -*- import os import hashlib import socket import re import urllib2 import pickle import time from sensu_plugin import SensuPluginMetricGraphite class NginxStatusMetrics ( SensuPluginMetricGraphite ): \"\"\" This is a script for check nginx status \"\"\" def __init__ ( self ): self . last_metrics_dir = '/tmp/.nginx_status_metrics' if not os . path . isdir ( self . last_metrics_dir ): os . mkdir ( self . last_metrics_dir ) super ( NginxStatusMetrics , self ) . __init__ () def setup ( self ): self . parser . add_argument ( '-u' , '--url' , default = 'http://localhost/nginx_status/' , help = 'nginx status url' ) self . parser . add_argument ( '-s' , '--schema' , default = '{0}.nginx.status' . format ( socket . gethostname ()), help = 'metrics schema' ) def _get_nginx_status ( self ): current_time = time . time () req = urllib2 . Request ( self . options . url ) try : response = urllib2 . urlopen ( req ) except : self . warning () res = response . read () pattern = re . compile ( r \"Active connections: (?P<activeconn>\\d+)\\s+\" \\ \"server accepts handled requests\\s+\" \\ \"(?P<accepts>\\d+)\\s+(?P<handled>\\d+)\\s+(?P<requests>\\d+)\\s+\" \"Reading: (?P<reading>\\d+)\\sWriting: (?P<writing>\\d+)\\s+Waiting: (?P<waiting>\\d+)\" ) matcher = pattern . match ( res ) if not matcher : self . warning () status = dict ( activeconn = matcher . group ( 'activeconn' ), accepts = matcher . group ( 'accepts' ), handled = matcher . group ( 'handled' ), requests = matcher . group ( 'requests' ), reading = matcher . group ( 'reading' ), writing = matcher . group ( 'writing' ), waiting = matcher . group ( 'waiting' ), ) # Write cached ret = dict ( executed_time = current_time , status = status ) pickle . dump ( ret , open ( self . last_metrics_file , 'w' )) return ret def run ( self ): url_md5 = hashlib . md5 ( self . options . url ) . hexdigest () self . last_metrics_file = os . path . join ( self . last_metrics_dir , url_md5 ) try : last_status = pickle . load ( open ( self . last_metrics_file )) except : last_status = dict () if not last_status : last_status = self . _get_nginx_status () time . sleep ( 1 ) current_status = self . _get_nginx_status () interval = current_status [ 'executed_time' ] - last_status [ 'executed_time' ] last_status = last_status [ 'status' ] current_status = current_status [ 'status' ] counter_map = [ 'accepts' , 'handled' , 'requests' ] for k , v in current_status . iteritems (): if k in counter_map : if int ( current_status [ k ]) > int ( last_status [ k ]): v = \" %.2f \" % (( int ( current_status [ k ]) - int ( last_status [ k ])) / interval ) k = k + 'rate' self . output ( \"{0},type={1},url_md5={2}\" . format ( self . options . schema , k , url_md5 ), v ) else : self . output ( \"{0},type={1},url_md5={2}\" . format ( self . options . schema , k , url_md5 ), v ) self . ok () if __name__ == \"__main__\" : NginxStatusMetrics ()","tags":"Sensu","title":"sensu插件nginx-status"},{"url":"django/django-debug-toolbar.html","text":"网上很多资料都是django1.4下的，无法正常显示toolbar。 地址： https://github.com/django-debug-toolbar/django-debug-toolbar 安装 # pip install django-debug-toolbar 设置settings.py INSTALLED_APPS = ( 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'blog', 'debug_toolbar', ) 设置MIDDLEWARE_CLASSES MIDDLEWARE_CLASSES = ( 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.auth.middleware.SessionAuthenticationMiddleware', 'debug_toolbar.middleware.DebugToolbarMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', 'django.middleware.security.SecurityMiddleware', ) 设置Debug_Show #Debug_Toolbar def show_toolbar(request): print request.user return True DEBUG_TOOLBAR_CONFIG = { 'SHOW_TOOLBAR_CALLBACK': 'simblog.settings.show_toolbar', 'JQUERY_URL': '//code.jquery.com/jquery-1.11.2.min.js', }","tags":"Django","title":"Django1.8 安装Django-Debug-Toolbar"},{"url":"web/web-lightbox2.html","text":"一直想为博客增加个图片浏览功能，今天研究了半天终于弄好啦，效果还是挺满意的。 插件用的是lightbox2： http://lokeshdhakar.com/projects/lightbox2/ 看了下说明文档，这个插件是根据 data-lightbox 属性来调用js的，但我的富文本编辑器默认不识别data-lightbox属性，保存之后会自动去掉，而且手动编辑加data-lightbox也很low。故在前端用js解决： <script type= \"text/javascript\" > $(document).ready(function() { //为图片添加超链接 $(\".post-content img\").each(function() { var strA = \" <a href= '\" + this.src + \"' data-lightbox= 'example' ></a> \"; $(this).wrapAll(strA); }); }); </script> 遇到的坑：lightbox2的js文件必须放到html末尾，放到head不执行。","tags":"Web","title":"lightbox2 图片放大浏览"},{"url":"nosql/nosql-mongodb-json.html","text":"导出数据 # mongodump -d test -o bak 导入数据 # mongorestore -h 127.0.0.1 --port 30000 -d test bak/test/ 导出集合为csv # mongoexport -h 127.0.0.1 --port 30000 -d test -c districts --type=csv -o districts.csv -f _id,district_code,province,city,district 导出集合为json # mongoexport -h 127.0.0.1 --port 30000 -d test -c districts -o districts.json 导入csv或者json # mongoimport -d test -c districts --type=json --file=districts.json --upsert 备注：以上导出数据库 test 的集合 districts，并将数据以 csv 格式导出。 -h 表示主机IP或主机名; -d 表示数据库名; -c 表示集合名; -f 表示所选集合的字段; -o 表示导出的文件名 --upsert 以新增的方式导入 --headerline 仅适用于导入csv,tsv格式的数据，表示文件中的第一行作为数据头","tags":"Nosql","title":"mongo集群 导入导出json和csv"},{"url":"django/django-html-mail.html","text":"1.settings.py文件中添加配置： # email config EMAIL_HOST = ' smtp .163 . com ' EMAIL_HOST_USER = ' bbaobelief @163. com ' EMAIL_HOST_PASSWORD = ' 123456 ' EMAIL_USE_TLS = True 2.发送简单邮件： from django.core.mail import send_mail send_mail ( '标题' , '内容' , 'bbaobelief@163.com' , [ '773889242@qq.com' ], fail_silently = True ) 3.发送html邮件 #mailer.py # -*- coding: utf-8 -*- from django.core.mail import EmailMessage from django.template import loader from amms.settings import EMAIL_HOST_USER #项目配置邮件地址，请参考发送普通邮件部分 import time def send_html_mail ( subject , content , recipient_list ): html_content = loader . render_to_string ( 'mail_template.html' , #需要渲染的html模板 { 'name' : content [ 'name' ], 'date' : time . strftime ( \"%Y-%m- %d %X \" , time . localtime ()), #参数 'info' : content [ 'info' ] } ) msg = EmailMessage ( subject , html_content , EMAIL_HOST_USER , recipient_list ) msg . content_subtype = \"html\" # Main content is now text/html msg . send () #send_html_mail(subject, html_content, [收件人列表]) 4.html模版 <span style= \"color: rgb(255, 0, 0);\" ><b> 你好: {{ name }} ，时间： {{ date }} ; </b></span> <b><font color= \"#ff00ff\" > 任务： {{ info }} </font></b> <html> <head></head> <body> <table cellspacing= \"1px\" style= \"width: 50%; border: 1px outset rgb(128, 128, 128); border-spacing: 1px;\" > <tbody> <tr> <td style= \"border:1px #808080 inset;padding:1px;\" > 申请人 </td> <td style= \"border:1px #808080 inset;padding:1px;\" > {{ name }} </td> </tr> <tr> <td style= \"border:1px #808080 inset;padding:1px;\" > 任务 </td> <td style= \"border:1px #808080 inset;padding:1px;\" > {{ info }} </td> </tr> <tr> <td style= \"border:1px #808080 inset;padding:1px;\" > 时间 </td> <td style= \"border:1px #808080 inset;padding:1px;\" > {{ date }} <br /></td> </tr> </tbody> </table> </body> </html> 5.发送调用 from workflow.mailer import * send_html_mail ( '你有待审批工单' , { 'name' : 'zheng' , 'info' : 'lvs vip申请' }, [ '773889242@qq.com' ,]) 6.效果演示 7.官方文档： https://docs.djangoproject.com/en/1.8/topics/email/","tags":"Django","title":"django 发送html模版渲染邮件"},{"url":"django/django-celery-redis.html","text":"关于celery介绍请自行百度 1.安装Celery 用pip或easy_install安装： # pip install Celery django-celery celery-with-redis 2.安装redis # wget http://download.redis.io/releases/redis-3.0.3.tar.gz # tar xzf redis-3.0.3.tar.gz # cd redis-3.0.3 # make # src/redis-server # src/redis-cli 3.Django设置 a.修改settings.py 在INSTALLED_APPS中加入app： INSTALLED_APPS = ( ... 'djcelery', } b.添加BROKER的配置： #djcelery+broker配置 import djcelery djcelery . setup_loader () BROKER_URL = 'redis://192.168.1.83:6379/0' #或者 #BROKER_HOST = \"192.168.1.83\" #BROKER_PORT = 6379 #BROKER_USER = \"\" #BROKER_PASSWORD = \"\" #BROKER_VHOST = \"0\" 4. 创建数据库 # python manage.py syncdb # 默认 # python manage.py migrate djcelery #South 5.创建一个task 在 django app 目录中创建 tasks . py : import time from celery import task @task () def add ( x , y ): return x + y @task def sendmail ( mail ): print \"++++++++++++++++++++++++++++++++++++\" print ( 'sending mail to %s ...' % mail [ 'to' ]) time . sleep ( 2.0 ) print ( 'mail sent.' ) print \"------------------------------------\" return mail [ 'to' ] 6.开启worker # python manage.py celery worker --loglevel=info 7.执行task，调用任务 >>> from workflow.tasks import * >>> sendmail . delay ( dict ( to = 'zheng@me.com' )) < AsyncResult : 694 b6fa8 - 0545 - 4 c22 - 9 ba2 - b77d7cbb066f > >>> add . delay ( 2 , 15 ) < AsyncResult : 42 d34419 - 071e-49 ab - 9627 - 45428 eaaeb38 > >>> a = add . delay ( 1 , 1 ) >>> a . ready () True >>> a . get () 2 >>> a = add . delay ( 10 , 5 ) >>> a . get () 15 8.实列 # views.py from workflow.tasks import add , sendmail def task_workorder ( request , id ): \"\"\"任务添加\"\"\" user = request . user if request . method == 'POST' : #提交请求时才会访问这一段，首次访问页面时不会执行 form = TaskForm ( request . POST or None , request . FILES ,) if form . is_valid (): print '++++++++++++++' print form . clean if request . POST . has_key ( 'sub' ): result = form . save ( commit = False ) result . state = 2 result . save () # 点击提交按钮则改变状态为已提交 sendmail . delay ( dict ( to = 'zheng@me.com' )) #申请人提交后会给审批人发邮件 else : form . save () return HttpResponseRedirect ( '/workflow/sqlist/' ) else : #首次访问该url时没有post任何表单 form = TaskForm ( initial = { 'type' : id , 'creator' : user . id , 'state' : 1 }) #第一次生成的form里面内容的格式 t = get_template ( 'workflow/add.html' ) c = RequestContext ( request , locals ()) return HttpResponse ( t . render ( c )) tasks.py # tasks.py @task def sendmail(mail): print \"++++++++++++++++++++++++++++++++++++\" print('sending mail to %s...' % mail['to']) time.sleep(2.0) print('mail sent.') print \"------------------------------------\" return mail['to']","tags":"Django","title":"django+Celery+redis异步执行任务"},{"url":"linux/uwsgi-nginx.html","text":"1. 安装必要的开发包 # yum install python-devel libxml2-devel python-setuptools zlib-devel wget pcre-devel gcc make 2. 安装nginx # useradd www # wget http://nginx.org/download/nginx-1.6.1.tar.gz # ./configure --user=www --group=www \\ --prefix=/usr/local/nginx \\ --with-http_stub_status_module \\ --with-http_gzip_static_module //此处在本环节只需指定一个路径 # make && make install # /usr/local/nginx/sbin/nginx //启Nginx 3.安装uwsgi # wget http://projects.unbit.it/downloads/uwsgi-2.0.6.tar.gz # tar -zxvf uwsgi-2.6.tar.gz # cd uwsgi-2.6.tar.gz # python setup.py build # make # mv uwsgi /usr/bin/ //将编译好的文件移动到此处 4.测试uwsgi 在你的机器上写一个test.py def application(env, start_response): start_response('200 OK', [('Content-Type','text/html')]) return \"Hello World\" 然后执行shell命令： # uwsgi --http :9000 --wsgi-file test.py #注意--http :9000之间有空格 访问网页： http://127.0.0.1:9001/ 看在网页上是否有Hello World 5.配置nginx vim / usr / local / nginx / conf / nginx . conf server { listen 80 ; server_name localhost ; #charset koi8-r ; access_log logs/access.log ; error_log logs/error.log ; location / { uwsgi_pass 127.0.0.1:9001 ; include uwsgi_params ; } # error_page 404 / 404 . html ; # redirect server error pages to the static page / 50x . html # error_page 500 502 503 504 / 50x . html ; location = / 50x . html { root html ; } location / static / { alias /data/www/django/mysite/aceadmin/static/ ; index index.html index.htm ; } location / media / { alias /data/www/django/mysite/aceadmin/media/ ; } } 6.配置django NOTE：请保证你的django项目是正常使用的。可以使用 python manage.py runserver 0.0.0.0:8002 来测试一下你的django项目是否能正常跑起来。 # cat django_wsgi.py #!/usr/bin/env python # coding: utf-8 import os import sys # 将系统的编码设置为UTF8 #reload(sys) #sys.setdefaultencoding('utf8') #注意：\"mysite.settings\" 和项目文件夹对应。 os . environ . setdefault ( \"DJANGO_SETTINGS_MODULE\" , \"myblog.settings\" ) from django.core.wsgi import get_wsgi_application application = get_wsgi_application () 连接 django 和 uwsgi ，实现简单的 WEB 服务器。 然后，就可以执行以下命令： # uwsgi --http :9001 --chdir /data/www/django/mysite --module django_wsgi 这样，你就可以在浏览器中访问你的Django程序了。所有的请求都是经过uwsgi传递给Django程序的。 7.配置uWSGI 新建一个XML文件： vim uwsgi.xml，将它放在 mysite 目录下： <uwsgi> <socket> 127.0.0.1:9001 </socket> <!-- 和nginx中定义的要一致 --> <chdir> /data/django/myblog </chdir> <!-- 你django的项目目录 --> <module> django_wsgi </module> <!-- 名称为刚才上面定义的py文件名 --> <processes> 4 </processes> <!-- 进程数 --> <daemonize> /data/django/myblog/log/uwsgi.log </daemonize> </uwsgi> 在上面的配置中，我们使用 uwsgi.log 来记录日志，开启4个进程来处理请求。 这样，我们就配置好uWSGI了。 启动uWSGI服务器 # cd/data/www/django/mysite # uwsgi -x uwsgi.xml 在上面的设置后，可以让Nginx来处理静态文件(/static/ 和 /media/ ）。非静态文件请求Nginx会发给 socket 9001，然后让uWSGI来进行处理。 8.其他设置 a.关闭django调试模式 DEBUG = False b.复制admin文件样式 1. 修改settings.py中STATIC_ROOT为你的static静态文件的物理路径 复制静态文件 # python manage.py collectstatic 修改Nginx配置 location /static { root /home/user/www; } 完成上面三步后，重新加载相应设置： 重启uwsgi和nginx","tags":"Linux","title":"nginx+uwsgi部署"},{"url":"django/duxcms-nginx.html","text":"今天部署了duxcms，想用来做移动端文章展示用，对默认生成的文章url不胜满意，找了下官方的资料没发现nginx的伪静态规则，于是自己写了个。 后台———系统———系统设置———性能设置———伪静态（开启） nginx加入伪静态规则 rewrite &#94;(.*)/article/([0-9]+).html$ $1/index.php?r=article/Content/index&content_id=$2 last; 补充官方方式： location / { try_files $uri $uri/ /index.php?$args; }","tags":"Django","title":"duxcms 开启nginx伪静态"},{"url":"django/django-forms-widget.html","text":"models.py class Task ( models . Model ) : '''任务表''' title = models . CharField ( u '标题' , max_length = 30 ) description = models . TextField ( u '描述' ) creator = models . ForeignKey ( User , verbose_name = u '创建人' ) type = models . ForeignKey ( 'Workorder' , verbose_name = u '任务类型' ) state = models . ForeignKey ( 'State' , verbose_name = u '当前状态' ) create_time = models . DateTimeField ( u '创建时间' , auto_now_add = True ) expire_Time = models . DateTimeField ( u '期望时间' ) finish_time = models . DateTimeField ( u '完成时间' , auto_now = True ) class Meta : verbose_name = u '任务创建' verbose_name_plural = verbose_name ordering = [ '-create_time' ] def __unicode__ ( self ) : return self . title 默认生成html中title input中没有size属性，是默认大小，如果自定义大小可以如下： forms.py 方法1：(重写了字段，此处不推荐) class TaskForm ( forms . ModelForm ) : title = forms . CharField ( label = u '标题0' , widget = forms . TextInput ( attrs = { 'size' : '10' })) class Meta : model = Task fields = \"__all__\" # exclude = [] # uncomment this line and specify any field to exclude it from the form def __init__ ( self , * args , ** kwargs ) : super ( TaskForm , self ). __init__ ( * args , ** kwargs ) 方法2：（推荐） class TaskForm ( forms . ModelForm ) : class Meta : model = Task fields = \"__all__\" # exclude = [] # uncomment this line and specify any field to exclude it from the form widgets = { 'title' : forms . Textarea ( attrs = { 'cols' : 20 , 'rows' : 5 }), } def __init__ ( self , * args , ** kwargs ) : super ( TaskForm , self ). __init__ ( * args , ** kwargs ) 附widgets教程： https://docs.djangoproject.com/en/dev/ref/forms/widgets/#module-django.forms.widgets","tags":"Django","title":"django 自定义 forms widget属性"},{"url":"django/django-related_name.html","text":"今天在设计models时，一张表用到了2个ManyToManyField字段，当同步数据库时报错如下： ERRORS : workflow . Workorder . auditor : ( fields . E304 ) Reverse accessor for 'Workorder.auditor' clashes with reverse accessor for 'Workorder.creator' . HINT : Add or change a related_name argument to the definition for 'Workorder.auditor' or 'Workorder.creator' . workflow . Workorder . auditor : ( fields . E304 ) Reverse accessor for 'Workorder.auditor' clashes with reverse accessor for 'Workorder.operator' . HINT : Add or change a related_name argument to the definition for 'Workorder.auditor' or 'Workorder.operator' . workflow . Workorder . creator : ( fields . E304 ) Reverse accessor for 'Workorder.creator' clashes with reverse accessor for 'Workorder.auditor' . HINT : Add or change a related_name argument to the definition for 'Workorder.creator' or 'Workorder.auditor' . workflow . Workorder . creator : ( fields . E304 ) Reverse accessor for 'Workorder.creator' clashes with reverse accessor for 'Workorder.operator' . HINT : Add or change a related_name argument to the definition for 'Workorder.creator' or 'Workorder.operator' . workflow . Workorder . operator : ( fields . E304 ) Reverse accessor for 'Workorder.operator' clashes with reverse accessor for 'Workorder.auditor' . HINT : Add or change a related_name argument to the definition for 'Workorder.operator' or 'Workorder.auditor' . workflow . Workorder . operator : ( fields . E304 ) Reverse accessor for 'Workorder.operator' clashes with reverse accessor for 'Workorder.creator' . HINT : Add or change a related_name argument to the definition for 'Workorder.operator' or 'Workorder.creator' . 根据报错内容得知，related_name 必须唯一，于是修改models如下 creator = models.ForeignKey(User, verbose_name=u'申请人') auditor = models.ManyToManyField(User,related_name='workorder_auditor', verbose_name=u'审批人') operator = models.ManyToManyField(User,related_name='workorder_operator', verbose_name=u'执行人')","tags":"Django","title":"django 报错.auditor: (fields.E304) Reverse accessor"},{"url":"linux/centos-vpn.html","text":"一、首先检查你VPS的PPP和TUN有没有启用： cat /dev/ppp cat /dev/net/tun 显示结果为： cat: /dev/ppp: No such device or address cat: /dev/net/tun: File descriptor in bad state 表明通过，上述两条只要有一个没通过都不行。如果没有启用，你可以给VPS提供商Submit 一个 Ticket请求开通： Hello Could you enabled TUN-TAP for me? I want run pptp-vpn on my VPS. Thank you. 确认 PPP 和 TUN 启用后，开始安装 ppp 和 iptables： yum install -y ppp iptables 二、安装pptp： （适用32位系统） rpm -ivh http://acelnmp.googlecode.com/files/pptpd-1.3.3-1.rhel4.1.i386.rpm （适用64位系统） rpm -ivh http://acelnmp.googlecode.com/files/pptpd-1.3.3-1.rhel4.x86_64.rpm 三、配置pptp，编辑/etc/pptpd.conf文件： vim /etc/pptpd.conf 把下面字段前面的#去掉： localip 192.168.0.1 remoteip 192.168.0.234-238,192.168.0.245 四、编辑/etc/ppp/options.pptpd 文件： vim /etc/ppp/options.pptpd 去掉ms-dns前面的#，并使用Google的DNS服务器，修改成如下字段： ms-dns 8.8.8.8 ms-dns 8.8.4.4 五、设置VPN账号密码，编辑/etc/ppp/chap-secrets这个文件： vim /etc/ppp/chap-secrets 六、修改内核设置，使其支持转发，编辑 /etc/sysctl.conf 文件： vim /etc/sysctl.conf 将\"net.ipv4.ip_forward\"的值改为1，同时在\"net.ipv4.tcp_syncookies = 1\"前面加# 七、使 sysctl.conf 配置文件生效并添加 iptables 转发规则： sysctl -p iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -j SNAT --to-source ***.***.***.*** (***.***.***.***为你VPS的公网IP地址) iptables -A POSTROUTING -t nat -s 192.168.0.0/24 -o eth0 -j MASQUERADE iptables -A INPUT -p tcp -m state --state NEW -m tcp --dport 1723 -j ACCEPT #注：这条命令尽量放在防火墙列表前面几条不然可能会阻止 保存iptables转发规则： /etc/init.d/iptables save 重启 iptables： /etc/init.d/iptables restart 重启pptp服务： /etc/init.d/pptpd restart 设置开机自动运行pptp服务： chkconfig pptpd on 设置开机自动运行iptables服务： chkconfig iptables on 到此安装配置结束了。","tags":"Linux","title":"Centos vps安装VPN"},{"url":"django/django-cache.html","text":"最近博客增加了许多新功能，访问速度有所下降，故启用了django的数据库全站缓存。 Django 官方缓存系统介绍： https://docs.djangoproject.com/en/1.8/topics/cache/#database-caching 配置cache方式及内部实现机制： django中cache大体分为三种，即针对全站的缓存配置、针对视图的缓存配置、针对数据的缓存配置。本站采用数据库+全站缓存。 1.设置缓存，在settings.py添加 CACHES = { 'default': { 'BACKEND': 'django.core.cache.backends.db.DatabaseCache', 'LOCATION': 'my_cache_table', # 要缓存的表名 'TIMEOUT': 600, # 默认的缓存有效时间,以秒计. 默认值是 300 秒(五分钟). 'OPTIONS': { 'MAX_ENTRIES': 1000 # 缓存的最大条目数(超出该数旧的缓存会被清除,默认值是 300). } } } 2.创建缓存表 python manage.py createcachetable 3.缓存整个站点 设置了缓存类型之后, 最简单使用缓存的方式就是缓存整个站点. 在 MIDDLEWARE_CLASSES 设置中添加 django.middleware.cache.CacheMiddleware , 就象下面的例子一样: MIDDLEWARE_CLASSES = ( 'django.middleware.cache.UpdateCacheMiddleware', # 注意位置，在前 'django.middleware.common.CommonMiddleware', 'django.middleware.cache.FetchFromCacheMiddleware', # 注意位置，在后 ) 4.在settings.py添加CACHE_MIDDLEWARE_SECONDS :每个页面应该被缓存的秒数。 CACHE_MIDDLEWARE_SECONDS = 500 # 每个页面应该被缓存的秒数 5.重启django,就可以体验缓存了。","tags":"Django","title":"django 设置 数据库缓存"},{"url":"django/django-m2m.html","text":"表结构 class Author ( models . Model ) : name = models . CharField ( max_length = 30 ) email = models . EmailField () class Book ( models . Model ) : title = models . CharField ( max_length = 200 ) authors = models . ManyToManyField ( Author , related_name = 'books' ) 通过Book查Author b = Book.objects.get(id=1) b.authors.all() # 查询id1的书籍作者 通过Author查Book a = Author.objects.get(id=1) a.book_set.all() # 查询作者id为1的所有书籍 a.books.all() # 通过自定义的related_name查","tags":"Django","title":"Django 多对多查询"},{"url":"web/google-code-prettify.html","text":"以前我使用 highlight.js,现在换了kindeditor编辑器。为了更好的兼容性，代码高亮插件改为Prettify，出现无法显示行号问题，记录解决方法。 1.修改code.js文件49行为 html = ' <pre class= \"prettyprint linenums' + cls + '\" > \\n' + K.escape(code) + ' </pre> '; 2.修改主题文件github.css，添加 /* IE indents via margin-left */ li . L0 , li . L1 , li . L2 , li . L3 , li . L4 , li . L5 , li . L6 , li . L7 , li . L8 , li . L9 { list-style-type : decimal !important } pre . prettyprint ol li { margin-left : 10 px ; padding-left : 10 px ; border-left : 2 px solid #BBE9BB ; } 3.自用hemisu.css主题样式 /* Hemisu Light */ /* Original theme - http://noahfrederick.com/vim-color-scheme-hemisu/ */ . prettyprint { background : white ; font-family : Menlo , 'Bitstream Vera Sans Mono' , 'DejaVu Sans Mono' , Monaco , Consolas , monospace ; font-size : 12 px ; line-height : 1.5 ; border : 1 px solid #ccc ; padding : 10 px ; } . pln { color : #111111 ; } @ media screen { . str { color : #739200 ; } . kwd { color : #739200 ; } . com { color : #999999 ; } . typ { color : #ff0055 ; } . lit { color : #538192 ; } . pun { color : #111111 ; } . opn { color : #111111 ; } . clo { color : #111111 ; } . tag { color : #111111 ; } . atn { color : #739200 ; } . atv { color : #ff0055 ; } . dec { color : #111111 ; } . var { color : #111111 ; } . fun { color : #538192 ; } } @ media print , projection { . str { color : #006600 ; } . kwd { color : #006 ; font-weight : bold ; } . com { color : #600 ; font-style : italic ; } . typ { color : #404 ; font-weight : bold ; } . lit { color : #004444 ; } . pun , . opn , . clo { color : #444400 ; } . tag { color : #006 ; font-weight : bold ; } . atn { color : #440044 ; } . atv { color : #006600 ; } } /* Specify class=linenums on a pre to get line numbering */ ol . linenums { margin-top : 0 ; margin-bottom : 0 ; } /* IE indents via margin-left */ li . L0 , li . L1 , li . L2 , li . L3 , li . L4 , li . L5 , li . L6 , li . L7 , li . L8 , li . L9 { list-style-type : decimal !important } /* Alternate shading for lines */ li . L1 , li . L3 , li . L5 , li . L7 , li . L9 { /* */ } pre . prettyprint ol li { margin-left : 10 px ; padding-left : 10 px ; border-left : 2 px solid #BBE9BB ; }","tags":"Web","title":"Google Code Prettify 代码高亮显示行号"},{"url":"other/ios-flex2.html","text":"由于搜狐视频版权问题，现在不能离线观看美剧，且现在ios8.3系统暂时没有人上传flex2的搜狐视频破解补丁，于是自己做了个，仅作破解记录。 一、确保ios已越狱且安装了flex2 二、去软件启动广告 搜索 LaunchAdvertItem , 找到 -(BOOL)existLaunchAdvertImage 并将其的值修改为 FALSE 即可。 三、去除视频广告 搜索 STADPauseView , 找到 -(id)initWithFrame:(CGRect) , 将其值改为 (NULL) 。 搜索 ASAdvertPlayerViewController , 找到 -(id)advertInfo , 将其值改为 (NULL) 。 四、去除美剧下载限制 搜索 VideoBaseInfo， 将-(BOOL)isDownloadable 的值改为 TURE 。 五、在flex2中启用补丁，现在就可以自由的无广告下载缓存美剧了。","tags":"Other","title":"Flex2 破解搜狐视频v5.0 去广告+美剧下载教程"},{"url":"python/python-base64.html","text":"最近看到一个好玩的js库 fartscroll.js ，可以让你页面每下拉一点就听到一声屁响。于是研究了一下工作原理： 滚动后向 HTML 文档中添加了 audio 元素，并且使用base64编码。使用 base64 编码的方式，避免了加载外部的音频资源。 演示地址： http://www.opdev.cn/admin/ 想自定义声音，怎么转换为Base64编码？ 用python获得Base64编码后的字符串: import base64 f = open ( r '/tmp/Teemo.mp3' , 'rb' ) #二进制方式打开MP3文件 mp3 = base64 . b64encode ( f . read ()) #读取文件内容，转换为base64编码 print mp3 f . close ()","tags":"Python","title":"python转换MP3文件为base64编码"},{"url":"django/django-input.html","text":"群友的问题：点击搜索后搜索内容不变为空，并且显示结果。 解决方案： 1.先用js获取input的value值，在点击提交事件之后重写修改input 的value值为搜索内容； 2.利用django获取request的值，返回搜索条件和结果给前端页面。 方法2实现： 1.编辑urls.py，添加 (r'blog/search/$', search_blog), 2.编辑views.py 添加search_blog方法 def search_blog(request): \"\"\"搜索\"\"\" if request.method == 'POST': article = request.POST.get('article') else: article = u'请输入标题' bloglist = Article.objects.filter(title__contains = article) t = get_template('search.html') c = RequestContext(request,locals()) return HttpResponse(t.render(c)) 3.修改search.html文件为 <form name= \"search_form\" action= \"\" method= \"post\" > {% csrf_token %} <input type= \"text\" name= \"article\" value= \" {{ article }} \" > <input type= \"submit\" value= \"搜索\" > </form> <p> 结果: </p> {{ bloglist }} 效果演示：","tags":"Django","title":"django input搜索提交 值不变"},{"url":"linux/nosql-redis.html","text":"环境介绍 os： centos 6.4 x64位系统 master: 192.168.1.83 slave: 192.168.1.84 两台机器安装redis 安装redis组件tcl # yum install tcl-devel.x86_64 tcl.x86_64 gcc 安装redis # tar zxvf redis-3.0.2.tar.gz # make PREFIX=/usr/local/redis install # make MALLOC=libc #若报错执行 生成配置 # /root/soft/redis-3.0.2/utils/install_server.sh # vim /etc/redis/6379.conf # 修改 daemonize yestimeout 500 logfile /data/redis/6379/log/redis_6379.log dir /data/redis/6379/data 创建目录 # mkdir /data/redis/6379/{data,log} -p 启动命令 # ln -s /usr/local/redis/bin/* /usr/bin/# mv /etc/init.d/redis_6379 /etc/init.d/redis 启动redis # service redis start 查看端口 # netstat -tunpl|grep redis slave服务器配置修改 # vim /etc/redis/6379.conf 在以下位置添加一行 # slaveof slaveof 192.168.1.83 6379 重启redis # service redis restart 查看端口 # netstat -tunpl|grep redis 测试主机数据同步 在master主机写入key [root@localhost redis]# redis-cli 127.0.0.1:6379> set name zheng OK 127.0.0.1:6379> keys * 1) \"name\" 在slave主机查看key [root@localhost conf]# redis-cli 127.0.0.1:6379> keys * 1) \"name\" 127.0.0.1:6379>set name zheng #默认是读写分离的 (error) READONLY You can't write against a read only slave. ####主从切换 1.停止master [root@localhost redis]# service redis stop Stopping ... Redis stopped [root@localhost redis]# redis-cli Could not connect to Redis at 127.0.0.1:6379: Connection refused not connected> 2.将从redis设成主redis [root@localhost ~]# redis-cli -p 6379 slaveof NO ONE OK 3.测试从redis是否切换从主redis [root@localhost ~]# redis-cli 127.0.0.1:6379> set name zhengfuqiang OK 原来的主redis恢复正常了，要重新切换回去 1.将现在的主redis的数据进行保存 [root@localhost ~]# redis-cli 127.0.0.1:6379> set name zhengfuqiang OK 127.0.0.1:6379> set age 24 OK 127.0.0.1:6379> set email zheng@qq.com OK 127.0.0.1:6379> save OK 2.将现在的主redis根目录下dump.rdb文件拷贝覆盖到原来主redis的根目录 # scp /data/redis/6379/data/dump.rdb root@192.168.1.83:/data/redis/6379/data/ 启动原来的master [root@localhost data]# service redis start Starting Redis server... [root@localhost data]# redis-cli 127.0.0.1:6379> keys * 1) \"pass\" 2) \"name\" 3) \"age\" 127.0.0.1:6379> [root@localhost data]# redis-cli slaveof 192.168.1.83 6379#在slave切换 OK [root@localhost data]# redis-cli 127.0.0.1:6379> keys * 1) \"name\" 2) \"pass\" 3) \"age\" 4) \"email\"","tags":"Linux","title":"redis3.0.2 主从搭建"},{"url":"django/django-template.html","text":"之前一直用django1.7版本，今天在新环境部署了django1.8,引用模版报错： TemplateDoesNotExist at /cmdb/index/ 查看官网文档找到如下解决方法： https://docs.djangoproject.com/en/dev/ref/templates/api/#django.template.loaders.filesystem.Loader TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates')],#修改settings.py把原来的[]改为TEMPLATE_DIRS的路径 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, ]","tags":"Django","title":"django1.8.2报错TemplateDoesNotEx"},{"url":"linux/yum-nginx-php-mysql.html","text":"环境:Contos6.4 32位 配置：2核+512memory+30disk Step1：安装Yum源 因为nginx和php-fpm都不能直接通过Yum直接安装，所以我们需要下载两个仓库到我们的VPS上。 # rpm -Uvh http://download.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm # rpm -Uvh http://rpms.famillecollet.com/enterprise/remi-release-6.rpm 报错1： Error : Cannot retrieve metalink for repository : epel . Please verify its path and try again 处理很简单，修改文件\"/etc/yum.repos.d/epel.repo\"，将baseurl的注释取消，mirrorlist注释掉。即可。 报错2： # yum [Errno 256] No more mirrors to try 解决方法 # yum clean all # yum makecache Step2：安装Mysql # yum install mysql mysql-server 安装完毕后，重启Mysql # /etc/init.d/mysqld restart 重启完后，我们可以启动Mysql的安全配置项 # /usr/bin/mysql_secure_installation Step3：安装nginx # yum install nginx # /etc/init.d/nginx start 在浏览器上直接输入ip地址测试 通过运行下面的命令来显示你服务器的ip地址。 ifconfig eth0 | grep inet | awk '{ print $2 }' Step4：安装php 因为php包是在REMI仓库中的，并且目前是被禁用的。我们首先要做的就是启用REMI仓库并且安装php和php-fpm还有php-mcrypt（phpmyadmin需要php-mcrypt和php-mbstring扩展，不安装可能会在启动phpmyadmin时候导致模块缺失的错误。你还可以选择安装其他所需要的扩展，已经在下面列出）。 # yum --enablerepo=remi,remi-php55 install php-fpm php-mysql php-mcrypt php-mbstring 更多扩展项如下： yum --enablerepo=remi,remi-php55 install php-cli php-gd php-pear php-mysqlnd php-pdo php-pgsql php-pecl-mongo php-sqlite php-pecl-memcached php-pecl-memcache php-mbstrin php-xml php-soap php-mcrypt php-fpm Step5：配置nginx 打开默认的nginx配置文件 # vi /etc/nginx/nginx.conf 将workerprocesses的数字提升到2，保存并退出。 现在来配置nginx的虚拟主机。 # vi /etc/nginx/conf.d/default.conf 相关配置和配置改动（在配置的下面）如下。 server { listen 80 ; server_name example.com ; location / { root /usr/share/nginx/html ; index index.php index.html index.htm ; } error_page 404 / 404 . html ; location = / 404 . html { root /usr/share/nginx/html ; } error_page 500 502 503 504 / 50x . html ; location = / 50x . html { root /usr/share/nginx/html ; } # pass the PHP scripts to FastCGI server listening on 127 . 0 . 0 . 1 : 9000 # location ~ \\ . php $ { root /usr/share/nginx/html ; fastcgi_pass 127.0.0.1:9000 ; fastcgi_index index.php ; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name ; include fastcgi_params ; } } 删除/etc/nginx/conf.d/目录下不用的配置 Step6：配置php-fpm 打开php-fpm配置 # vi /etc/php-fpm.d/www.conf 在用户和组中，用nginx代替apache user = nginx group = nginx 保存并重启php-fpm。 # service php-fpm restart Setp7：创建phpinfo测试 首先我们创建一个新的文件。 # vi /usr/share/nginx/html/info.php 加入 <?php phpinfo (); ?> ; 保存并退出。 重启nginx，使配置生效。（注：将来对配置进行任何更改后，都要重启，配置才会生效。） 访问你在配置中输入的域名或者ip地址对应的phpinfo页面。 http://IP/info.php Step8：设置自启动。 最后一步就是将刚刚装的所有程序设置自启动。 # chkconfig --levels 235 mysqld on # chkconfig --levels 235 nginx on # chkconfig --levels 235 php-fpm on 恭喜，你已经完成了配置部分","tags":"Linux","title":"yum安装PHP+Nginx+Mysql"},{"url":"linux/linux-mail.html","text":"由于公司API服务器需要统计用户访问信息，于是编写了shell脚本发送统计信息到邮箱。 但收到的邮件出现乱码，解决过程记录： 现象 使用Foxmail客户端收取邮件中文出现乱码，如\"报告生成时间???2015-05-14 00:30 总???问???:515076\"； 使用web邮箱收取邮件无内容，只显示附件为tcmime.1101.1101.4747.bin之类的内容； 分析 检查脚本文件编码是否为utf-8（可vi进去后，:set fileencoding查看）; 检测系统环境是否安装了中文包支持（使用 locale命令）； 检查shell命令行和crond环境变量是否一致（使用env查看） 解决 我这里的中文乱码原因是因为shell命令行和crond环境变量不一致导致，脚本中加入export LANG=en_US.UTF-8","tags":"linux","title":"mail命令发送邮件中文乱码或附件为tcmime.*.bin"},{"url":"python/python-wechat.html","text":"今天在群里看到有人问：微信如何发送报警信息，自己简单看了下。 注册体验号 地址： http://qydev.weixin.qq.com/try?t=experience 进行注册操作，默认有90天的期限。 # -*- coding: utf-8 -*- import sys import urllib2 import json reload ( sys ) sys . setdefaultencoding ( 'utf-8' ) class Token ( object ): '''微信接口发送消息''' def __init__ ( self , corp_id , corp_secret ): self . corp_id = corp_id self . corp_secret = corp_secret self . baseurl = 'https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid={0}&corpsecret={1}' . format ( self . corp_id , self . corp_secret ) self . send_values = {} #获取AccessToken def get_token ( self ): request = urllib2 . Request ( self . baseurl ) try : response = urllib2 . urlopen ( request , timeout = 10 ) except urllib2 . HTTPError as e : print e . code token_data = response . read () . strip () token_json = json . loads ( token_data ) if 'errcode' in token_json . keys (): print token_json [ 'errmsg' ] sys . exit ( 1 ) self . access_token = token_json [ 'access_token' ] return self . access_token #发送消息 def send_data ( self , message ): self . message = message self . send_url = 'https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=' + self . access_token self . send_values = { \"touser\" : \"@all\" , \"msgtype\" : \"text\" , \"agentid\" : \"2\" , \"text\" : { \"content\" : message }, \"safe\" : \"0\" } send_data = json . dumps ( self . send_values , ensure_ascii = False ) send_request = urllib2 . Request ( self . send_url , send_data ) response = urllib2 . urlopen ( send_request ) # 返回微信公共平台的信息 msg = response . read () print msg corpid = '你的corpid' corpsecret = '你的corpsecret' message = \" [擦汗][擦汗] Nagios 警报 [擦汗][擦汗] \\n\\n 类型 : RECOVERY \\n 主机 : web-001 \\n 状态 : UP \\n 地址 : 192.168.1.1 \\n 日志 : OK - load average: 0.00, 0.00, 0.00 \\n\\n 时间 : Mon May 5 15:10:18 CST 2015 \\n \" get_test = Token ( corpid , corpsecret ) get_test . get_token () msg = get_test . send_data ( message ) 演示效果","tags":"Python","title":"python版微信企业号发送报警信息"},{"url":"django/django-simblog.html","text":"概述 此博客系统基于Django-1.7.7开发而成，通过nginx+uwsgi运行于 locvps (每月31元，优惠码： mc20150325 - 仅限洛杉矶MC机房5折终身优惠)上，Python版本为 2.7.6。 功能，感谢Chopstack提供主题。 1.文章、分类和页面的增删 2.文章按年、月 3.集成simditor富文本编 4.集成Prettify代码 5.集成多说 6.rss和sitemap 备注 1.为什么使用simditor而不用markdown，个人比较喜欢simditor的简洁美观，还有不习惯markdown的语法； 2.为什么使用highlight而不用Pygments，有洁癖，不想安装第三方插件让后端程序太臃肿； 3.为什么使用多说评论而不用django自带的评论，你会为了评论去注册帐号吗？","tags":"Django","title":"django博客simblog"}]}